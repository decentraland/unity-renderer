import * as path from 'path'
import { glob } from 'glob'
import {
  camelToSnakeCase,
  cleanGeneratedCode,
  execute,
  normalizePath,
  protocolPath,
  protocPath,
  workingDirectory,
} from './helpers'
import * as fs from 'node:fs'
import { readFileSync, writeFileSync } from 'node:fs'

const protocolInputPath = normalizePath(path.resolve(protocolPath))

const componentsOutputPath = path.resolve(
  __dirname,
  '../../unity-renderer/Assets/Scripts/MainScripts/DCL/DecentralandProtocol/',
)

async function main() {
  await execute(`${protocPath} --version`, workingDirectory)

  await buildProtocol()
}

const regex = new RegExp(/option *\(common.ecs_component_id\) *= *([0-9]+) *;/)

const getComponentId = (text: string): string | null => {
  const res = text.match(regex)
  if (res && res.length >= 1) return res[1]
  return null
}

type ComponentData = { componentName: string; componentId: number }

function generateComponentsEnum(components: ComponentData[]) {
  components.sort((first, second) => first.componentId - second.componentId)
  let content: string = ''

  content += '/* Autogenerated file, DO NOT EDIT! */\n'
  content += 'namespace DCL.ECS7\n'
  content += '{\n'
  content += '    public static class ComponentID \n'
  content += '    {\n'

  content += '        public const int TRANSFORM = 1;\n'
  for (const component of components) {
    let componentUpperCaseName = camelToSnakeCase(
      component.componentName,
    ).toUpperCase()

    content += `        public const int ${componentUpperCaseName} = ${component.componentId.toString()};\n`
  }
  content += '    }\n'
  content += '}\n'

  const outputPath = path.resolve(componentsOutputPath, 'ComponentID.gen.cs')
  fs.writeFileSync(outputPath, content)
}

function fixEngineInterface() {
  const engineInterfaceProtoPath = normalizePath(
    path.resolve(
      protocolInputPath,
      'decentraland/renderer/engine_interface.proto',
    ),
  )
  const content = readFileSync(engineInterfaceProtoPath).toString()

  const newContent = content.replace(
    '// option csharp_namespace = "DCL.Interface";',
    'option csharp_namespace = "DCL.Interface";',
  )

  writeFileSync(engineInterfaceProtoPath, newContent)
}

async function preProcessComponents() {
  const protoFiles = glob.sync(
    normalizePath(
      path.resolve(protocolInputPath, 'decentraland/sdk/components/**/*.proto'),
    ),
  )
  const components: ComponentData[] = []

  for (const file of protoFiles) {
    const content = fs.readFileSync(file).toString()
    const lines = content.split('\n')
    let newComponentId = null

    for (const line of lines) {
      const componentId = getComponentId(line)
      if (componentId) {
        newComponentId = Number(componentId)
      }
    }

    if (newComponentId) {
      const fileName = path.basename(file)
      const componentName = fileName.replace('.proto', '')
      components.push({
        componentId: newComponentId,
        componentName,
      })
    }
  }

  generateComponentsEnum(components)
}

function getProtofiles(pattern: string)
{
  return glob
    .sync(
      normalizePath(path.resolve(protocolInputPath, pattern)),
    )
}

async function buildProtocol() {
  console.log('Building protocol...')
  cleanGeneratedCode(componentsOutputPath)
  fixEngineInterface()
  await preProcessComponents()

  const protoFiles = [
    ...getProtofiles('decentraland/common/**/*.proto'),
    ...getProtofiles('decentraland/sdk/components/**/*.proto'),
    ...getProtofiles('decentraland/bff/**/*.proto'),
    ...getProtofiles('decentraland/renderer/**/*.proto')
  ].join(' ')

  let command = `${protocPath}`
  command += ` --csharp_out "${componentsOutputPath}"`
  command += ` --csharp_opt=file_extension=.gen.cs`
  command += ` --proto_path "${protocolInputPath}"`
  command += ` ${protoFiles}`

  await execute(command, workingDirectory)

  console.log('Building protocol... Done!')
}

main().catch((err) => {
  console.error(err)
  process.exit(1)
})
