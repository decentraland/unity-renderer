// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: decentraland/sdk/components/text_shape.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace DCL.ECSComponents {

  /// <summary>Holder for reflection information generated from decentraland/sdk/components/text_shape.proto</summary>
  public static partial class TextShapeReflection {

    #region Descriptor
    /// <summary>File descriptor for decentraland/sdk/components/text_shape.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TextShapeReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CixkZWNlbnRyYWxhbmQvc2RrL2NvbXBvbmVudHMvdGV4dF9zaGFwZS5wcm90",
            "bxIbZGVjZW50cmFsYW5kLnNkay5jb21wb25lbnRzGiBkZWNlbnRyYWxhbmQv",
            "Y29tbW9uL2NvbG9ycy5wcm90bxouZGVjZW50cmFsYW5kL3Nkay9jb21wb25l",
            "bnRzL2NvbW1vbi90ZXh0cy5wcm90byKbCAoLUEJUZXh0U2hhcGUSDAoEdGV4",
            "dBgBIAEoCRI7CgRmb250GAIgASgOMiguZGVjZW50cmFsYW5kLnNkay5jb21w",
            "b25lbnRzLmNvbW1vbi5Gb250SACIAQESFgoJZm9udF9zaXplGAMgASgCSAGI",
            "AQESGwoOZm9udF9hdXRvX3NpemUYBCABKAhIAogBARJKCgp0ZXh0X2FsaWdu",
            "GAUgASgOMjEuZGVjZW50cmFsYW5kLnNkay5jb21wb25lbnRzLmNvbW1vbi5U",
            "ZXh0QWxpZ25Nb2RlSAOIAQESEgoFd2lkdGgYBiABKAJIBIgBARITCgZoZWln",
            "aHQYByABKAJIBYgBARIYCgtwYWRkaW5nX3RvcBgIIAEoAkgGiAEBEhoKDXBh",
            "ZGRpbmdfcmlnaHQYCSABKAJIB4gBARIbCg5wYWRkaW5nX2JvdHRvbRgKIAEo",
            "AkgIiAEBEhkKDHBhZGRpbmdfbGVmdBgLIAEoAkgJiAEBEhkKDGxpbmVfc3Bh",
            "Y2luZxgMIAEoAkgKiAEBEhcKCmxpbmVfY291bnQYDSABKAVIC4gBARIaCg10",
            "ZXh0X3dyYXBwaW5nGA4gASgISAyIAQESGAoLc2hhZG93X2JsdXIYDyABKAJI",
            "DYgBARIcCg9zaGFkb3dfb2Zmc2V0X3gYECABKAJIDogBARIcCg9zaGFkb3df",
            "b2Zmc2V0X3kYESABKAJID4gBARIaCg1vdXRsaW5lX3dpZHRoGBIgASgCSBCI",
            "AQESNgoMc2hhZG93X2NvbG9yGBMgASgLMhsuZGVjZW50cmFsYW5kLmNvbW1v",
            "bi5Db2xvcjNIEYgBARI3Cg1vdXRsaW5lX2NvbG9yGBQgASgLMhsuZGVjZW50",
            "cmFsYW5kLmNvbW1vbi5Db2xvcjNIEogBARI0Cgp0ZXh0X2NvbG9yGBUgASgL",
            "MhsuZGVjZW50cmFsYW5kLmNvbW1vbi5Db2xvcjRIE4gBAUIHCgVfZm9udEIM",
            "CgpfZm9udF9zaXplQhEKD19mb250X2F1dG9fc2l6ZUINCgtfdGV4dF9hbGln",
            "bkIICgZfd2lkdGhCCQoHX2hlaWdodEIOCgxfcGFkZGluZ190b3BCEAoOX3Bh",
            "ZGRpbmdfcmlnaHRCEQoPX3BhZGRpbmdfYm90dG9tQg8KDV9wYWRkaW5nX2xl",
            "ZnRCDwoNX2xpbmVfc3BhY2luZ0INCgtfbGluZV9jb3VudEIQCg5fdGV4dF93",
            "cmFwcGluZ0IOCgxfc2hhZG93X2JsdXJCEgoQX3NoYWRvd19vZmZzZXRfeEIS",
            "ChBfc2hhZG93X29mZnNldF95QhAKDl9vdXRsaW5lX3dpZHRoQg8KDV9zaGFk",
            "b3dfY29sb3JCEAoOX291dGxpbmVfY29sb3JCDQoLX3RleHRfY29sb3JCFKoC",
            "EURDTC5FQ1NDb21wb25lbnRzYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Decentraland.Common.ColorsReflection.Descriptor, global::DCL.ECSComponents.TextsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::DCL.ECSComponents.PBTextShape), global::DCL.ECSComponents.PBTextShape.Parser, new[]{ "Text", "Font", "FontSize", "FontAutoSize", "TextAlign", "Width", "Height", "PaddingTop", "PaddingRight", "PaddingBottom", "PaddingLeft", "LineSpacing", "LineCount", "TextWrapping", "ShadowBlur", "ShadowOffsetX", "ShadowOffsetY", "OutlineWidth", "ShadowColor", "OutlineColor", "TextColor" }, new[]{ "Font", "FontSize", "FontAutoSize", "TextAlign", "Width", "Height", "PaddingTop", "PaddingRight", "PaddingBottom", "PaddingLeft", "LineSpacing", "LineCount", "TextWrapping", "ShadowBlur", "ShadowOffsetX", "ShadowOffsetY", "OutlineWidth", "ShadowColor", "OutlineColor", "TextColor" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The TextShape component renders customizable floating text.
  ///
  /// The position and rotation of the text are defined by the Entity's Transform, while its size
  /// can either scale with the Transform or be fixed by a font size.
  ///
  /// Several options can be configured, including color, padding, line spacing and drop shadows.
  /// </summary>
  public sealed partial class PBTextShape : pb::IMessage<PBTextShape>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PBTextShape> _parser = new pb::MessageParser<PBTextShape>(() => new PBTextShape());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PBTextShape> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DCL.ECSComponents.TextShapeReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PBTextShape() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PBTextShape(PBTextShape other) : this() {
      _hasBits0 = other._hasBits0;
      text_ = other.text_;
      font_ = other.font_;
      fontSize_ = other.fontSize_;
      fontAutoSize_ = other.fontAutoSize_;
      textAlign_ = other.textAlign_;
      width_ = other.width_;
      height_ = other.height_;
      paddingTop_ = other.paddingTop_;
      paddingRight_ = other.paddingRight_;
      paddingBottom_ = other.paddingBottom_;
      paddingLeft_ = other.paddingLeft_;
      lineSpacing_ = other.lineSpacing_;
      lineCount_ = other.lineCount_;
      textWrapping_ = other.textWrapping_;
      shadowBlur_ = other.shadowBlur_;
      shadowOffsetX_ = other.shadowOffsetX_;
      shadowOffsetY_ = other.shadowOffsetY_;
      outlineWidth_ = other.outlineWidth_;
      shadowColor_ = other.shadowColor_ != null ? other.shadowColor_.Clone() : null;
      outlineColor_ = other.outlineColor_ != null ? other.outlineColor_.Clone() : null;
      textColor_ = other.textColor_ != null ? other.textColor_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PBTextShape Clone() {
      return new PBTextShape(this);
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 1;
    private string text_ = "";
    /// <summary>
    /// the content
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Text {
      get { return text_; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "font" field.</summary>
    public const int FontFieldNumber = 2;
    private global::DCL.ECSComponents.Font font_;
    /// <summary>
    /// the font (default F_SANS_SERIF)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::DCL.ECSComponents.Font Font {
      get { if ((_hasBits0 & 1) != 0) { return font_; } else { return global::DCL.ECSComponents.Font.FSansSerif; } }
      set {
        _hasBits0 |= 1;
        font_ = value;
      }
    }
    /// <summary>Gets whether the "font" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFont {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "font" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFont() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "font_size" field.</summary>
    public const int FontSizeFieldNumber = 3;
    private float fontSize_;
    /// <summary>
    /// the font size (default 10)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FontSize {
      get { if ((_hasBits0 & 2) != 0) { return fontSize_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        fontSize_ = value;
      }
    }
    /// <summary>Gets whether the "font_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFontSize {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "font_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFontSize() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "font_auto_size" field.</summary>
    public const int FontAutoSizeFieldNumber = 4;
    private bool fontAutoSize_;
    /// <summary>
    /// override `font_size` to automatically fit in `width`/`height`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FontAutoSize {
      get { if ((_hasBits0 & 4) != 0) { return fontAutoSize_; } else { return false; } }
      set {
        _hasBits0 |= 4;
        fontAutoSize_ = value;
      }
    }
    /// <summary>Gets whether the "font_auto_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFontAutoSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "font_auto_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFontAutoSize() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "text_align" field.</summary>
    public const int TextAlignFieldNumber = 5;
    private global::DCL.ECSComponents.TextAlignMode textAlign_;
    /// <summary>
    /// X and Y alignment (default TAM_CENTER_CENTER)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::DCL.ECSComponents.TextAlignMode TextAlign {
      get { if ((_hasBits0 & 8) != 0) { return textAlign_; } else { return global::DCL.ECSComponents.TextAlignMode.TamTopLeft; } }
      set {
        _hasBits0 |= 8;
        textAlign_ = value;
      }
    }
    /// <summary>Gets whether the "text_align" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTextAlign {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "text_align" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTextAlign() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "width" field.</summary>
    public const int WidthFieldNumber = 6;
    private float width_;
    /// <summary>
    /// available horizontal space (default 1)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Width {
      get { if ((_hasBits0 & 16) != 0) { return width_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        width_ = value;
      }
    }
    /// <summary>Gets whether the "width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWidth {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWidth() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "height" field.</summary>
    public const int HeightFieldNumber = 7;
    private float height_;
    /// <summary>
    /// available vertical space (default 1)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Height {
      get { if ((_hasBits0 & 32) != 0) { return height_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        height_ = value;
      }
    }
    /// <summary>Gets whether the "height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHeight {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHeight() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "padding_top" field.</summary>
    public const int PaddingTopFieldNumber = 8;
    private float paddingTop_;
    /// <summary>
    /// distance from text to top border (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PaddingTop {
      get { if ((_hasBits0 & 64) != 0) { return paddingTop_; } else { return 0F; } }
      set {
        _hasBits0 |= 64;
        paddingTop_ = value;
      }
    }
    /// <summary>Gets whether the "padding_top" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddingTop {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "padding_top" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddingTop() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "padding_right" field.</summary>
    public const int PaddingRightFieldNumber = 9;
    private float paddingRight_;
    /// <summary>
    /// distance from text to right border (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PaddingRight {
      get { if ((_hasBits0 & 128) != 0) { return paddingRight_; } else { return 0F; } }
      set {
        _hasBits0 |= 128;
        paddingRight_ = value;
      }
    }
    /// <summary>Gets whether the "padding_right" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddingRight {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "padding_right" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddingRight() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "padding_bottom" field.</summary>
    public const int PaddingBottomFieldNumber = 10;
    private float paddingBottom_;
    /// <summary>
    /// distance from text to bottom border (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PaddingBottom {
      get { if ((_hasBits0 & 256) != 0) { return paddingBottom_; } else { return 0F; } }
      set {
        _hasBits0 |= 256;
        paddingBottom_ = value;
      }
    }
    /// <summary>Gets whether the "padding_bottom" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddingBottom {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "padding_bottom" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddingBottom() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "padding_left" field.</summary>
    public const int PaddingLeftFieldNumber = 11;
    private float paddingLeft_;
    /// <summary>
    /// distance from text to left border (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PaddingLeft {
      get { if ((_hasBits0 & 512) != 0) { return paddingLeft_; } else { return 0F; } }
      set {
        _hasBits0 |= 512;
        paddingLeft_ = value;
      }
    }
    /// <summary>Gets whether the "padding_left" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPaddingLeft {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "padding_left" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPaddingLeft() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "line_spacing" field.</summary>
    public const int LineSpacingFieldNumber = 12;
    private float lineSpacing_;
    /// <summary>
    /// extra distance between lines (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float LineSpacing {
      get { if ((_hasBits0 & 1024) != 0) { return lineSpacing_; } else { return 0F; } }
      set {
        _hasBits0 |= 1024;
        lineSpacing_ = value;
      }
    }
    /// <summary>Gets whether the "line_spacing" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLineSpacing {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "line_spacing" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLineSpacing() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "line_count" field.</summary>
    public const int LineCountFieldNumber = 13;
    private int lineCount_;
    /// <summary>
    /// maximum number of lines to display
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int LineCount {
      get { if ((_hasBits0 & 2048) != 0) { return lineCount_; } else { return 0; } }
      set {
        _hasBits0 |= 2048;
        lineCount_ = value;
      }
    }
    /// <summary>Gets whether the "line_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLineCount {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "line_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLineCount() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "text_wrapping" field.</summary>
    public const int TextWrappingFieldNumber = 14;
    private bool textWrapping_;
    /// <summary>
    /// wrap text when the border is reached (default false)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TextWrapping {
      get { if ((_hasBits0 & 4096) != 0) { return textWrapping_; } else { return false; } }
      set {
        _hasBits0 |= 4096;
        textWrapping_ = value;
      }
    }
    /// <summary>Gets whether the "text_wrapping" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTextWrapping {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "text_wrapping" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTextWrapping() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "shadow_blur" field.</summary>
    public const int ShadowBlurFieldNumber = 15;
    private float shadowBlur_;
    /// <summary>
    /// blurriness of the drop shadow (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ShadowBlur {
      get { if ((_hasBits0 & 8192) != 0) { return shadowBlur_; } else { return 0F; } }
      set {
        _hasBits0 |= 8192;
        shadowBlur_ = value;
      }
    }
    /// <summary>Gets whether the "shadow_blur" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasShadowBlur {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "shadow_blur" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearShadowBlur() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "shadow_offset_x" field.</summary>
    public const int ShadowOffsetXFieldNumber = 16;
    private float shadowOffsetX_;
    /// <summary>
    /// horizontal length of the shadow (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ShadowOffsetX {
      get { if ((_hasBits0 & 16384) != 0) { return shadowOffsetX_; } else { return 0F; } }
      set {
        _hasBits0 |= 16384;
        shadowOffsetX_ = value;
      }
    }
    /// <summary>Gets whether the "shadow_offset_x" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasShadowOffsetX {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "shadow_offset_x" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearShadowOffsetX() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "shadow_offset_y" field.</summary>
    public const int ShadowOffsetYFieldNumber = 17;
    private float shadowOffsetY_;
    /// <summary>
    /// vertical length of the shadow (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ShadowOffsetY {
      get { if ((_hasBits0 & 32768) != 0) { return shadowOffsetY_; } else { return 0F; } }
      set {
        _hasBits0 |= 32768;
        shadowOffsetY_ = value;
      }
    }
    /// <summary>Gets whether the "shadow_offset_y" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasShadowOffsetY {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "shadow_offset_y" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearShadowOffsetY() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "outline_width" field.</summary>
    public const int OutlineWidthFieldNumber = 18;
    private float outlineWidth_;
    /// <summary>
    /// width of the stroke outlining each letter (default 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float OutlineWidth {
      get { if ((_hasBits0 & 65536) != 0) { return outlineWidth_; } else { return 0F; } }
      set {
        _hasBits0 |= 65536;
        outlineWidth_ = value;
      }
    }
    /// <summary>Gets whether the "outline_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOutlineWidth {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "outline_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOutlineWidth() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "shadow_color" field.</summary>
    public const int ShadowColorFieldNumber = 19;
    private global::Decentraland.Common.Color3 shadowColor_;
    /// <summary>
    /// drop shadow color (default [1.0, 1.0, 1.0])
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Decentraland.Common.Color3 ShadowColor {
      get { return shadowColor_; }
      set {
        shadowColor_ = value;
      }
    }

    /// <summary>Field number for the "outline_color" field.</summary>
    public const int OutlineColorFieldNumber = 20;
    private global::Decentraland.Common.Color3 outlineColor_;
    /// <summary>
    /// outline stroke color (default [1.0, 1.0, 1.0])
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Decentraland.Common.Color3 OutlineColor {
      get { return outlineColor_; }
      set {
        outlineColor_ = value;
      }
    }

    /// <summary>Field number for the "text_color" field.</summary>
    public const int TextColorFieldNumber = 21;
    private global::Decentraland.Common.Color4 textColor_;
    /// <summary>
    /// text color (default [1.0, 1.0, 1.0])
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Decentraland.Common.Color4 TextColor {
      get { return textColor_; }
      set {
        textColor_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PBTextShape);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PBTextShape other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Text != other.Text) return false;
      if (Font != other.Font) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FontSize, other.FontSize)) return false;
      if (FontAutoSize != other.FontAutoSize) return false;
      if (TextAlign != other.TextAlign) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Width, other.Width)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Height, other.Height)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PaddingTop, other.PaddingTop)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PaddingRight, other.PaddingRight)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PaddingBottom, other.PaddingBottom)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PaddingLeft, other.PaddingLeft)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LineSpacing, other.LineSpacing)) return false;
      if (LineCount != other.LineCount) return false;
      if (TextWrapping != other.TextWrapping) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ShadowBlur, other.ShadowBlur)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ShadowOffsetX, other.ShadowOffsetX)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ShadowOffsetY, other.ShadowOffsetY)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OutlineWidth, other.OutlineWidth)) return false;
      if (!object.Equals(ShadowColor, other.ShadowColor)) return false;
      if (!object.Equals(OutlineColor, other.OutlineColor)) return false;
      if (!object.Equals(TextColor, other.TextColor)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Text.Length != 0) hash ^= Text.GetHashCode();
      if (HasFont) hash ^= Font.GetHashCode();
      if (HasFontSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FontSize);
      if (HasFontAutoSize) hash ^= FontAutoSize.GetHashCode();
      if (HasTextAlign) hash ^= TextAlign.GetHashCode();
      if (HasWidth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Width);
      if (HasHeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Height);
      if (HasPaddingTop) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PaddingTop);
      if (HasPaddingRight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PaddingRight);
      if (HasPaddingBottom) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PaddingBottom);
      if (HasPaddingLeft) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PaddingLeft);
      if (HasLineSpacing) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LineSpacing);
      if (HasLineCount) hash ^= LineCount.GetHashCode();
      if (HasTextWrapping) hash ^= TextWrapping.GetHashCode();
      if (HasShadowBlur) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ShadowBlur);
      if (HasShadowOffsetX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ShadowOffsetX);
      if (HasShadowOffsetY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ShadowOffsetY);
      if (HasOutlineWidth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OutlineWidth);
      if (shadowColor_ != null) hash ^= ShadowColor.GetHashCode();
      if (outlineColor_ != null) hash ^= OutlineColor.GetHashCode();
      if (textColor_ != null) hash ^= TextColor.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Text.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Text);
      }
      if (HasFont) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Font);
      }
      if (HasFontSize) {
        output.WriteRawTag(29);
        output.WriteFloat(FontSize);
      }
      if (HasFontAutoSize) {
        output.WriteRawTag(32);
        output.WriteBool(FontAutoSize);
      }
      if (HasTextAlign) {
        output.WriteRawTag(40);
        output.WriteEnum((int) TextAlign);
      }
      if (HasWidth) {
        output.WriteRawTag(53);
        output.WriteFloat(Width);
      }
      if (HasHeight) {
        output.WriteRawTag(61);
        output.WriteFloat(Height);
      }
      if (HasPaddingTop) {
        output.WriteRawTag(69);
        output.WriteFloat(PaddingTop);
      }
      if (HasPaddingRight) {
        output.WriteRawTag(77);
        output.WriteFloat(PaddingRight);
      }
      if (HasPaddingBottom) {
        output.WriteRawTag(85);
        output.WriteFloat(PaddingBottom);
      }
      if (HasPaddingLeft) {
        output.WriteRawTag(93);
        output.WriteFloat(PaddingLeft);
      }
      if (HasLineSpacing) {
        output.WriteRawTag(101);
        output.WriteFloat(LineSpacing);
      }
      if (HasLineCount) {
        output.WriteRawTag(104);
        output.WriteInt32(LineCount);
      }
      if (HasTextWrapping) {
        output.WriteRawTag(112);
        output.WriteBool(TextWrapping);
      }
      if (HasShadowBlur) {
        output.WriteRawTag(125);
        output.WriteFloat(ShadowBlur);
      }
      if (HasShadowOffsetX) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ShadowOffsetX);
      }
      if (HasShadowOffsetY) {
        output.WriteRawTag(141, 1);
        output.WriteFloat(ShadowOffsetY);
      }
      if (HasOutlineWidth) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(OutlineWidth);
      }
      if (shadowColor_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ShadowColor);
      }
      if (outlineColor_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(OutlineColor);
      }
      if (textColor_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(TextColor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Text.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Text);
      }
      if (HasFont) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Font);
      }
      if (HasFontSize) {
        output.WriteRawTag(29);
        output.WriteFloat(FontSize);
      }
      if (HasFontAutoSize) {
        output.WriteRawTag(32);
        output.WriteBool(FontAutoSize);
      }
      if (HasTextAlign) {
        output.WriteRawTag(40);
        output.WriteEnum((int) TextAlign);
      }
      if (HasWidth) {
        output.WriteRawTag(53);
        output.WriteFloat(Width);
      }
      if (HasHeight) {
        output.WriteRawTag(61);
        output.WriteFloat(Height);
      }
      if (HasPaddingTop) {
        output.WriteRawTag(69);
        output.WriteFloat(PaddingTop);
      }
      if (HasPaddingRight) {
        output.WriteRawTag(77);
        output.WriteFloat(PaddingRight);
      }
      if (HasPaddingBottom) {
        output.WriteRawTag(85);
        output.WriteFloat(PaddingBottom);
      }
      if (HasPaddingLeft) {
        output.WriteRawTag(93);
        output.WriteFloat(PaddingLeft);
      }
      if (HasLineSpacing) {
        output.WriteRawTag(101);
        output.WriteFloat(LineSpacing);
      }
      if (HasLineCount) {
        output.WriteRawTag(104);
        output.WriteInt32(LineCount);
      }
      if (HasTextWrapping) {
        output.WriteRawTag(112);
        output.WriteBool(TextWrapping);
      }
      if (HasShadowBlur) {
        output.WriteRawTag(125);
        output.WriteFloat(ShadowBlur);
      }
      if (HasShadowOffsetX) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ShadowOffsetX);
      }
      if (HasShadowOffsetY) {
        output.WriteRawTag(141, 1);
        output.WriteFloat(ShadowOffsetY);
      }
      if (HasOutlineWidth) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(OutlineWidth);
      }
      if (shadowColor_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ShadowColor);
      }
      if (outlineColor_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(OutlineColor);
      }
      if (textColor_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(TextColor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Text.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (HasFont) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Font);
      }
      if (HasFontSize) {
        size += 1 + 4;
      }
      if (HasFontAutoSize) {
        size += 1 + 1;
      }
      if (HasTextAlign) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TextAlign);
      }
      if (HasWidth) {
        size += 1 + 4;
      }
      if (HasHeight) {
        size += 1 + 4;
      }
      if (HasPaddingTop) {
        size += 1 + 4;
      }
      if (HasPaddingRight) {
        size += 1 + 4;
      }
      if (HasPaddingBottom) {
        size += 1 + 4;
      }
      if (HasPaddingLeft) {
        size += 1 + 4;
      }
      if (HasLineSpacing) {
        size += 1 + 4;
      }
      if (HasLineCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(LineCount);
      }
      if (HasTextWrapping) {
        size += 1 + 1;
      }
      if (HasShadowBlur) {
        size += 1 + 4;
      }
      if (HasShadowOffsetX) {
        size += 2 + 4;
      }
      if (HasShadowOffsetY) {
        size += 2 + 4;
      }
      if (HasOutlineWidth) {
        size += 2 + 4;
      }
      if (shadowColor_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ShadowColor);
      }
      if (outlineColor_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OutlineColor);
      }
      if (textColor_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TextColor);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PBTextShape other) {
      if (other == null) {
        return;
      }
      if (other.Text.Length != 0) {
        Text = other.Text;
      }
      if (other.HasFont) {
        Font = other.Font;
      }
      if (other.HasFontSize) {
        FontSize = other.FontSize;
      }
      if (other.HasFontAutoSize) {
        FontAutoSize = other.FontAutoSize;
      }
      if (other.HasTextAlign) {
        TextAlign = other.TextAlign;
      }
      if (other.HasWidth) {
        Width = other.Width;
      }
      if (other.HasHeight) {
        Height = other.Height;
      }
      if (other.HasPaddingTop) {
        PaddingTop = other.PaddingTop;
      }
      if (other.HasPaddingRight) {
        PaddingRight = other.PaddingRight;
      }
      if (other.HasPaddingBottom) {
        PaddingBottom = other.PaddingBottom;
      }
      if (other.HasPaddingLeft) {
        PaddingLeft = other.PaddingLeft;
      }
      if (other.HasLineSpacing) {
        LineSpacing = other.LineSpacing;
      }
      if (other.HasLineCount) {
        LineCount = other.LineCount;
      }
      if (other.HasTextWrapping) {
        TextWrapping = other.TextWrapping;
      }
      if (other.HasShadowBlur) {
        ShadowBlur = other.ShadowBlur;
      }
      if (other.HasShadowOffsetX) {
        ShadowOffsetX = other.ShadowOffsetX;
      }
      if (other.HasShadowOffsetY) {
        ShadowOffsetY = other.ShadowOffsetY;
      }
      if (other.HasOutlineWidth) {
        OutlineWidth = other.OutlineWidth;
      }
      if (other.shadowColor_ != null) {
        if (shadowColor_ == null) {
          ShadowColor = new global::Decentraland.Common.Color3();
        }
        ShadowColor.MergeFrom(other.ShadowColor);
      }
      if (other.outlineColor_ != null) {
        if (outlineColor_ == null) {
          OutlineColor = new global::Decentraland.Common.Color3();
        }
        OutlineColor.MergeFrom(other.OutlineColor);
      }
      if (other.textColor_ != null) {
        if (textColor_ == null) {
          TextColor = new global::Decentraland.Common.Color4();
        }
        TextColor.MergeFrom(other.TextColor);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Text = input.ReadString();
            break;
          }
          case 16: {
            Font = (global::DCL.ECSComponents.Font) input.ReadEnum();
            break;
          }
          case 29: {
            FontSize = input.ReadFloat();
            break;
          }
          case 32: {
            FontAutoSize = input.ReadBool();
            break;
          }
          case 40: {
            TextAlign = (global::DCL.ECSComponents.TextAlignMode) input.ReadEnum();
            break;
          }
          case 53: {
            Width = input.ReadFloat();
            break;
          }
          case 61: {
            Height = input.ReadFloat();
            break;
          }
          case 69: {
            PaddingTop = input.ReadFloat();
            break;
          }
          case 77: {
            PaddingRight = input.ReadFloat();
            break;
          }
          case 85: {
            PaddingBottom = input.ReadFloat();
            break;
          }
          case 93: {
            PaddingLeft = input.ReadFloat();
            break;
          }
          case 101: {
            LineSpacing = input.ReadFloat();
            break;
          }
          case 104: {
            LineCount = input.ReadInt32();
            break;
          }
          case 112: {
            TextWrapping = input.ReadBool();
            break;
          }
          case 125: {
            ShadowBlur = input.ReadFloat();
            break;
          }
          case 133: {
            ShadowOffsetX = input.ReadFloat();
            break;
          }
          case 141: {
            ShadowOffsetY = input.ReadFloat();
            break;
          }
          case 149: {
            OutlineWidth = input.ReadFloat();
            break;
          }
          case 154: {
            if (shadowColor_ == null) {
              ShadowColor = new global::Decentraland.Common.Color3();
            }
            input.ReadMessage(ShadowColor);
            break;
          }
          case 162: {
            if (outlineColor_ == null) {
              OutlineColor = new global::Decentraland.Common.Color3();
            }
            input.ReadMessage(OutlineColor);
            break;
          }
          case 170: {
            if (textColor_ == null) {
              TextColor = new global::Decentraland.Common.Color4();
            }
            input.ReadMessage(TextColor);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Text = input.ReadString();
            break;
          }
          case 16: {
            Font = (global::DCL.ECSComponents.Font) input.ReadEnum();
            break;
          }
          case 29: {
            FontSize = input.ReadFloat();
            break;
          }
          case 32: {
            FontAutoSize = input.ReadBool();
            break;
          }
          case 40: {
            TextAlign = (global::DCL.ECSComponents.TextAlignMode) input.ReadEnum();
            break;
          }
          case 53: {
            Width = input.ReadFloat();
            break;
          }
          case 61: {
            Height = input.ReadFloat();
            break;
          }
          case 69: {
            PaddingTop = input.ReadFloat();
            break;
          }
          case 77: {
            PaddingRight = input.ReadFloat();
            break;
          }
          case 85: {
            PaddingBottom = input.ReadFloat();
            break;
          }
          case 93: {
            PaddingLeft = input.ReadFloat();
            break;
          }
          case 101: {
            LineSpacing = input.ReadFloat();
            break;
          }
          case 104: {
            LineCount = input.ReadInt32();
            break;
          }
          case 112: {
            TextWrapping = input.ReadBool();
            break;
          }
          case 125: {
            ShadowBlur = input.ReadFloat();
            break;
          }
          case 133: {
            ShadowOffsetX = input.ReadFloat();
            break;
          }
          case 141: {
            ShadowOffsetY = input.ReadFloat();
            break;
          }
          case 149: {
            OutlineWidth = input.ReadFloat();
            break;
          }
          case 154: {
            if (shadowColor_ == null) {
              ShadowColor = new global::Decentraland.Common.Color3();
            }
            input.ReadMessage(ShadowColor);
            break;
          }
          case 162: {
            if (outlineColor_ == null) {
              OutlineColor = new global::Decentraland.Common.Color3();
            }
            input.ReadMessage(OutlineColor);
            break;
          }
          case 170: {
            if (textColor_ == null) {
              TextColor = new global::Decentraland.Common.Color4();
            }
            input.ReadMessage(TextColor);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
